/**
 * Open 3D Viewer Library
 * Simplified version for the Section Box implementation
 */

const O3D = (function() {
    class Viewer {
        constructor(domElement) {
            this.container = domElement;
            this.scene = new THREE.Scene();
            this.camera = new THREE.PerspectiveCamera(60, this.container.clientWidth / this.container.clientHeight, 0.1, 1000);
            this.renderer = new THREE.WebGLRenderer({ antialias: true });
            this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
            this.renderer.setClearColor(0xf0f0f0);
            this.container.appendChild(this.renderer.domElement);
            
            // Setup lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            this.scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 2, 3);
            this.scene.add(directionalLight);
            
            // Setup camera
            this.camera.position.set(5, 5, 5);
            this.camera.lookAt(0, 0, 0);
            
            // Setup controls
            this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
            this.controls.enableDamping = true;
            this.controls.dampingFactor = 0.1;
            
            // Setup for clipping planes
            this.renderer.localClippingEnabled = true;
            
            // For compatibility with the requested API
            this.viewer = {
                impl: {
                    renderer: this.renderer,
                    invalidate: function(force) {
                        this.needsUpdate = true;
                    }
                }
            };
            
            // Start animation loop
            this.animate();
            
            // Handle window resize
            window.addEventListener('resize', () => this.onResize());
        }
        
        animate() {
            requestAnimationFrame(() => this.animate());
            this.controls.update();
            this.renderer.render(this.scene, this.camera);
        }
        
        onResize() {
            this.camera.aspect = this.container.clientWidth / this.container.clientHeight;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
        }
        
        AddModel(model) {
            this.scene.add(model);
            
            // Center camera on model
            const box = new THREE.Box3().setFromObject(model);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            
            const maxDim = Math.max(size.x, size.y, size.z);
            const distance = maxDim * 2;
            
            this.camera.position.copy(center);
            this.camera.position.x += distance;
            this.camera.position.y += distance;
            this.camera.position.z += distance;
            this.camera.lookAt(center);
            
            this.controls.target.copy(center);
        }
    }
    
    function LoadModelFromUrlList(urls, onSuccess, onError) {
        // Mock implementation for IFC loading
        const loader = new THREE.IFCLoader();
        
        if (urls.length > 0) {
            const url = urls[0];
            
            // Check if the file is an IFC file
            if (url.endsWith('.ifc')) {
                // Create a placeholder model for the example
                const geometry = new THREE.BoxGeometry(10, 10, 10);
                const material = new THREE.MeshStandardMaterial({ color: 0x4080ff, transparent: true, opacity: 0.8 });
                const cube = new THREE.Mesh(geometry, material);
                
                // Add some more elements to make it look like a building
                const buildingGroup = new THREE.Group();
                
                // Base/foundation
                const baseGeometry = new THREE.BoxGeometry(15, 1, 12);
                const baseMaterial = new THREE.MeshStandardMaterial({ color: 0xcccccc });
                const base = new THREE.Mesh(baseGeometry, baseMaterial);
                base.position.y = -5.5;
                buildingGroup.add(base);
                
                // Walls
                const walls = [
                    { size: [14, 10, 1], pos: [0, 0, 5.5], color: 0xeeeeee }, // front
                    { size: [14, 10, 1], pos: [0, 0, -5.5], color: 0xeeeeee }, // back
                    { size: [1, 10, 12], pos: [7, 0, 0], color: 0xdddddd }, // right
                    { size: [1, 10, 12], pos: [-7, 0, 0], color: 0xdddddd } // left
                ];
                
                walls.forEach(wall => {
                    const wallGeo = new THREE.BoxGeometry(wall.size[0], wall.size[1], wall.size[2]);
                    const wallMat = new THREE.MeshStandardMaterial({ color: wall.color });
                    const wallMesh = new THREE.Mesh(wallGeo, wallMat);
                    wallMesh.position.set(wall.pos[0], wall.pos[1], wall.pos[2]);
                    buildingGroup.add(wallMesh);
                });
                
                // Windows
                const windows = [
                    { pos: [-3, 0, 5.6], size: [2, 2, 0.1] },
                    { pos: [0, 0, 5.6], size: [2, 2, 0.1] },
                    { pos: [3, 0, 5.6], size: [2, 2, 0.1] }
                ];
                
                windows.forEach(window => {
                    const windowGeo = new THREE.BoxGeometry(window.size[0], window.size[1], window.size[2]);
                    const windowMat = new THREE.MeshStandardMaterial({ 
                        color: 0x88ccff, 
                        transparent: true,
                        opacity: 0.7
                    });
                    const windowMesh = new THREE.Mesh(windowGeo, windowMat);
                    windowMesh.position.set(window.pos[0], window.pos[1], window.pos[2]);
                    buildingGroup.add(windowMesh);
                });
                
                // Roof
                const roofGeometry = new THREE.ConeGeometry(8, 5, 4);
                const roofMaterial = new THREE.MeshStandardMaterial({ color: 0x994433 });
                const roof = new THREE.Mesh(roofGeometry, roofMaterial);
                roof.position.y = 7.5;
                roof.rotation.y = Math.PI / 4;
                buildingGroup.add(roof);
                
                // Interior walls
                const interiorWalls = [
                    { size: [7, 10, 0.5], pos: [3.5, 0, 0], color: 0xf8f8f8 },
                    { size: [0.5, 10, 5], pos: [0, 0, -2.5], color: 0xf8f8f8 }
                ];
                
                interiorWalls.forEach(wall => {
                    const wallGeo = new THREE.BoxGeometry(wall.size[0], wall.size[1], wall.size[2]);
                    const wallMat = new THREE.MeshStandardMaterial({ color: wall.color });
                    const wallMesh = new THREE.Mesh(wallGeo, wallMat);
                    wallMesh.position.set(wall.pos[0], wall.pos[1], wall.pos[2]);
                    buildingGroup.add(wallMesh);
                });
                
                // Successfully loaded
                if (onSuccess) {
                    onSuccess(buildingGroup);
                }
            } else {
                // Handle other file types
                if (onError) {
                    onError(new Error('Unsupported file format'));
                }
            }
        } else {
            if (onError) {
                onError(new Error('No URLs provided'));
            }
        }
    }
    
    // Add OrbitControls to THREE if not already there
    if (!THREE.OrbitControls) {
        THREE.OrbitControls = function(camera, domElement) {
            this.object = camera;
            this.domElement = domElement;
            this.enabled = true;
            this.target = new THREE.Vector3();
            this.enableDamping = false;
            this.dampingFactor = 0.05;
            
            this.update = function() {
                // Empty update method for this simplified example
            };
        };
    }
    
    // Add IFCLoader if not already in THREE
    if (!THREE.IFCLoader) {
        THREE.IFCLoader = function() {
            this.load = function(url, onLoad, onProgress, onError) {
                // This is a stub for the loader
            };
        };
    }
    
    return {
        Viewer: Viewer,
        LoadModelFromUrlList: LoadModelFromUrlList
    };
})();